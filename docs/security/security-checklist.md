# ASH Security Guide

This document provides a technical overview of ASH's security design, assumptions, and best practices.

If you are looking to report a vulnerability, please see:
[SECURITY.md](../../SECURITY.md)

For system architecture, see:
[architecture.md](architecture.md)

This guide focuses on how ASH works internally and how to use it securely.

---

## Security Philosophy

ASH is designed to protect applications from:

- Request tampering
- Replay attacks
- Data manipulation
- Client-side parameter abuse

ASH enforces request integrity and single-use validation.

It is designed to be used alongside existing security controls such as:

- HTTPS/TLS
- Authentication
- Authorization
- Input validation
- WAF/Firewall

ASH is not a replacement for full application security.
It serves as an additional protection layer.

---

## Supported Versions

| Package | Version | Supported |
|---------|---------|-----------|
| `ashcore` (Rust) | 1.0.x (beta) | Yes |
| `@3maem/ash-node-sdk` | 1.x (beta) | Yes |

Security patches are only provided for actively supported versions.
Please upgrade regularly.

---

## Threat Model Assumptions

ASH assumes:

- Requests are generated by a legitimate client at creation time
- HTTPS/TLS is used for transport
- Authentication/authorization is handled externally
- The server environment is not already compromised

If these assumptions do not hold, additional controls are required.

---

## Security Boundaries

### ASH provides

- Request integrity validation
- Single-use enforcement
- Replay protection
- Binding validation

### ASH does NOT provide

- Authentication
- Authorization
- Malware protection
- Intrusion detection

ASH validates whether a request was altered or replayed, not whether it is logically safe.

---

## Cryptographic Design

| Feature | Implementation |
|---------|----------------|
| Proof Generation | HMAC-SHA256 |
| Body Hashing | SHA-256 |
| Comparison | Constant-time |
| Nonce Generation | CSPRNG (Rust: `getrandom`; Node.js: application responsibility) |
| Key Derivation | HMAC-SHA256 (single-pass) |

All cryptographic operations follow modern security best practices.

---

## Anti-Replay Protection

ASH prevents replay attacks using:

- Single-use contexts (consumed on verification)
- TTL expiration
- Endpoint binding validation
- Timestamp verification

Each request can only be validated once.

---

## Defense-in-Depth Features

Additional protections include:

- Constant-time comparisons
- Secure memory clearing (Rust: `zeroize` crate; Node.js: best-effort `destroy()`)
- Context isolation
- Expiration enforcement

These reduce the feasibility of side-channel and replay attacks.

---

## Secure Configuration Best Practices

### 1. Keep Dependencies Updated

#### Node.js

```bash
npm audit && npm update
```

#### Rust

```bash
cargo update && cargo audit
```

---

### 2. Context TTL Configuration

- Default: 300 seconds (5 minutes)
- Clock skew tolerance: 30 seconds
- Use shorter TTLs for high-value operations

Shorter TTLs reduce the replay attack window.

---

### 3. Storage Recommendations

#### Production

- Redis with TLS (use `AshRedisStore`)
- Custom stores implementing the `AshContextStore` interface

#### Development

- In-memory store (`AshMemoryStore`) for local development only

#### Avoid

- In-memory stores in clustered/distributed deployments
- Shared state without synchronization

---

### 4. Binding Validation

Always verify request binding on the server:

```typescript
import { ashNormalizeBinding } from '@3maem/ash-node-sdk';

const expectedBinding = ashNormalizeBinding('POST', '/api/transfer', '');
if (context.binding !== expectedBinding) {
    throw new Error('Endpoint mismatch');
}
```

This prevents endpoint substitution attacks.

---

### 5. Secure Memory Usage

The Node.js SDK provides `destroy()` on build results to dereference sensitive data:

```typescript
import { ashBuildRequest } from '@3maem/ash-node-sdk';

const result = ashBuildRequest({
    nonce, contextId, method: 'POST', path: '/api/transfer',
    body: JSON.stringify({ amount: 100 }),
});

// Use result.proof, result.bodyHash, etc.

result.destroy(); // Dereference sensitive data when done
```

Note: In JavaScript/V8, `destroy()` dereferences sensitive values but cannot guarantee cryptographic zeroization due to garbage collection. The Rust crate (`ashcore`) provides true zeroization via the `zeroize` crate.

---

## Security Testing

The Node.js SDK includes comprehensive security test suites:

- Adversarial input tests (attack simulation)
- Security audit tests
- Property-based tests

---

## Recommendations for Production

When deploying ASH:

- Always use HTTPS
- Use short context TTLs
- Monitor logs for error code spikes
- Enable rate limiting
- Use latest version
- Test under load
- Keep server clocks synchronized (NTP)

---

## Final Notes

Security is a shared responsibility.

ASH strengthens request integrity, but secure architecture and operational practices remain essential.
