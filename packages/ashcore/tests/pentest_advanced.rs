//! Advanced Penetration Tests for ASH Rust SDK
//!
//! Tests protocol-level attacks, cryptographic attacks, timing attacks,
//! encoding attacks, and resource exhaustion scenarios.

use ashcore::{
    ash_build_proof, ash_verify_proof, ash_derive_client_secret,
    ash_canonicalize_json, ash_canonicalize_query,
    ash_hash_body, ash_timing_safe_equal, ash_normalize_binding,
    ash_build_proof_scoped, ash_verify_proof_scoped,
    ash_build_proof_unified, ash_verify_proof_unified,
};

// =========================================================================
// PROTOCOL-LEVEL ATTACKS
// =========================================================================

mod protocol_attacks {
    use super::*;

    #[test]
    fn test_binding_confusion_attack() {
        // Attacker tries to use context from one binding for another
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let timestamp = chrono::Utc::now().timestamp().to_string();
        let body_hash = ash_hash_body("{}");

        // Create proof for GET /api/users
        let binding1 = "GET|/api/users|";
        let secret1 = ash_derive_client_secret(&nonce, context_id, binding1).unwrap();
        let proof = ash_build_proof(&secret1, &timestamp, binding1, &body_hash).unwrap();

        // Try to use it for POST /api/users - should fail
        let binding2 = "POST|/api/users|";
        let result = ash_verify_proof(&nonce, context_id, binding2, &timestamp, &body_hash, &proof).unwrap();
        assert!(!result, "Binding confusion attack should fail");
    }

    #[test]
    fn test_method_swap_attack() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let timestamp = chrono::Utc::now().timestamp().to_string();
        let body_hash = ash_hash_body("{}");

        let binding_get = "GET|/api/admin|";
        let binding_post = "POST|/api/admin|";

        let secret = ash_derive_client_secret(&nonce, context_id, binding_get).unwrap();
        let proof = ash_build_proof(&secret, &timestamp, binding_get, &body_hash).unwrap();

        // Verify with wrong method
        let result = ash_verify_proof(&nonce, context_id, binding_post, &timestamp, &body_hash, &proof).unwrap();
        assert!(!result, "Method swap attack should fail");
    }

    #[test]
    fn test_path_traversal_attack() {
        // Attacker tries path traversal in binding
        let result = ash_normalize_binding("GET", "/api/../admin", "");
        assert!(result.is_ok());
        let normalized = result.unwrap();
        // Path should be normalized, not contain ..
        assert!(!normalized.contains(".."), "Path traversal should be normalized");
    }

    #[test]
    fn test_double_dot_path_attack() {
        let result = ash_normalize_binding("GET", "/api/users/../admin/../../etc/passwd", "");
        assert!(result.is_ok());
        let normalized = result.unwrap();
        assert!(!normalized.contains(".."));
    }

    #[test]
    fn test_query_parameter_pollution() {
        // Multiple same-named parameters
        let query = "admin=false&admin=true&role=user&role=admin";
        let result = ash_canonicalize_query(query).unwrap();

        // Should be sorted consistently
        assert!(result.contains("admin="));
        assert!(result.contains("role="));
    }

    #[test]
    fn test_query_order_manipulation() {
        let query1 = "b=2&a=1";
        let query2 = "a=1&b=2";

        let canon1 = ash_canonicalize_query(query1).unwrap();
        let canon2 = ash_canonicalize_query(query2).unwrap();

        assert_eq!(canon1, canon2, "Query order should not affect canonicalization");
    }

    #[test]
    fn test_null_byte_injection() {
        // Null bytes in input should be handled
        let json = "{\"key\":\"value\\u0000injected\"}";
        let result = ash_canonicalize_json(json);
        // Should either error or properly escape
        if let Ok(canonical) = result {
            assert!(canonical.contains("\\u0000") || !canonical.contains('\0'));
        }
    }

    #[test]
    fn test_context_id_injection() {
        let nonce = "a".repeat(64);
        // Try to inject delimiter into context_id
        let result = ash_derive_client_secret(&nonce, "ctx|injected", "GET|/|");
        // Pipe character is not in allowed context_id charset â€” must be rejected
        assert!(result.is_err());
    }
}

// =========================================================================
// CRYPTOGRAPHIC ATTACKS
// =========================================================================

mod crypto_attacks {
    use super::*;

    #[test]
    fn test_length_extension_prevention() {
        // HMAC is not vulnerable to length extension attacks
        // Verify that extending the message doesn't allow forging
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let binding = "POST|/api/test|";
        let timestamp = "1700000000";
        let body_hash = ash_hash_body("original");

        let secret = ash_derive_client_secret(&nonce, context_id, binding).unwrap();
        let proof = ash_build_proof(&secret, timestamp, binding, &body_hash).unwrap();

        // Try to verify with extended body
        let extended_body_hash = ash_hash_body("original_extended");
        let result = ash_verify_proof(&nonce, context_id, binding, timestamp, &extended_body_hash, &proof).unwrap();
        assert!(!result, "Length extension should not work");
    }

    #[test]
    fn test_collision_resistance() {
        // Different inputs should produce different hashes
        let hash1 = ash_hash_body("input1");
        let hash2 = ash_hash_body("input2");
        assert_ne!(hash1, hash2);

        // Very similar inputs
        let hash3 = ash_hash_body(&"a".repeat(1000));
        let hash4 = ash_hash_body(&format!("{}b", "a".repeat(1000)));
        assert_ne!(hash3, hash4);
    }

    #[test]
    fn test_key_derivation_uniqueness() {
        let nonce = "a".repeat(64);
        let binding = "POST|/api|";

        let secret1 = ash_derive_client_secret(&nonce, "ctx_1", binding).unwrap();
        let secret2 = ash_derive_client_secret(&nonce, "ctx_2", binding).unwrap();

        assert_ne!(secret1, secret2, "Different context IDs should produce different secrets");
    }

    #[test]
    fn test_proof_uniqueness_per_timestamp() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let binding = "POST|/api|";
        let body_hash = "b".repeat(64);

        let secret = ash_derive_client_secret(&nonce, context_id, binding).unwrap();

        let proof1 = ash_build_proof(&secret, "1700000001", binding, &body_hash).unwrap();
        let proof2 = ash_build_proof(&secret, "1700000002", binding, &body_hash).unwrap();

        assert_ne!(proof1, proof2, "Different timestamps should produce different proofs");
    }

    #[test]
    fn test_proof_uniqueness_per_body() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let binding = "POST|/api|";
        let timestamp = "1700000000";

        let secret = ash_derive_client_secret(&nonce, context_id, binding).unwrap();

        let proof1 = ash_build_proof(&secret, timestamp, binding, &ash_hash_body("body1")).unwrap();
        let proof2 = ash_build_proof(&secret, timestamp, binding, &ash_hash_body("body2")).unwrap();

        assert_ne!(proof1, proof2, "Different bodies should produce different proofs");
    }

    #[test]
    fn test_hmac_key_sensitivity() {
        let binding = "POST|/api|";
        let timestamp = "1700000000";
        let body_hash = "b".repeat(64);

        let nonce1 = "a".repeat(64);
        let nonce2 = "b".repeat(64);

        let secret1 = ash_derive_client_secret(&nonce1, "ctx", binding).unwrap();
        let secret2 = ash_derive_client_secret(&nonce2, "ctx", binding).unwrap();

        let proof1 = ash_build_proof(&secret1, timestamp, binding, &body_hash).unwrap();
        let proof2 = ash_build_proof(&secret2, timestamp, binding, &body_hash).unwrap();

        assert_ne!(proof1, proof2, "Different nonces should produce completely different proofs");
    }
}

// =========================================================================
// TIMING ATTACKS
// =========================================================================

mod timing_attacks {
    use super::*;
    use std::time::Instant;

    #[test]
    fn test_timing_safe_equal_constant_time() {
        // Run multiple comparisons and check timing consistency
        let s1 = "a".repeat(64);
        let s2_same = "a".repeat(64);
        let s2_diff_start = "b".repeat(64);
        let s2_diff_end = format!("{}b", "a".repeat(63));

        // Warm up
        for _ in 0..1000 {
            let _ = ash_timing_safe_equal(s1.as_bytes(), s2_same.as_bytes());
        }

        let iterations = 10000;

        // Time comparison with same string
        let start = Instant::now();
        for _ in 0..iterations {
            let _ = ash_timing_safe_equal(s1.as_bytes(), s2_same.as_bytes());
        }
        let time_same = start.elapsed();

        // Time comparison with difference at start
        let start = Instant::now();
        for _ in 0..iterations {
            let _ = ash_timing_safe_equal(s1.as_bytes(), s2_diff_start.as_bytes());
        }
        let time_diff_start = start.elapsed();

        // Time comparison with difference at end
        let start = Instant::now();
        for _ in 0..iterations {
            let _ = ash_timing_safe_equal(s1.as_bytes(), s2_diff_end.as_bytes());
        }
        let time_diff_end = start.elapsed();

        // Times should be relatively similar (within 50% - generous for test stability)
        let max_time = time_same.max(time_diff_start).max(time_diff_end);
        let min_time = time_same.min(time_diff_start).min(time_diff_end);

        // Allow for some variance but catch obvious timing leaks
        assert!(
            max_time.as_nanos() < min_time.as_nanos() * 3,
            "Timing variance too high: max={:?}, min={:?}",
            max_time, min_time
        );
    }

    #[test]
    fn test_verification_no_early_exit() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let binding = "POST|/api/test|";
        let timestamp = chrono::Utc::now().timestamp().to_string();
        let body_hash = "b".repeat(64);

        let secret = ash_derive_client_secret(&nonce, context_id, binding).unwrap();
        let valid_proof = ash_build_proof(&secret, &timestamp, binding, &body_hash).unwrap();

        // Create proofs that differ at different positions
        let mut wrong_start = valid_proof.clone();
        wrong_start.replace_range(0..1, "0");

        let mut wrong_middle = valid_proof.clone();
        wrong_middle.replace_range(32..33, "0");

        let mut wrong_end = valid_proof.clone();
        wrong_end.replace_range(63..64, "0");

        let iterations = 1000;

        // Time verification with wrong start
        let start = Instant::now();
        for _ in 0..iterations {
            let _ = ash_verify_proof(&nonce, context_id, binding, &timestamp, &body_hash, &wrong_start);
        }
        let time_wrong_start = start.elapsed();

        // Time verification with wrong middle
        let start = Instant::now();
        for _ in 0..iterations {
            let _ = ash_verify_proof(&nonce, context_id, binding, &timestamp, &body_hash, &wrong_middle);
        }
        let time_wrong_middle = start.elapsed();

        // Time verification with wrong end
        let start = Instant::now();
        for _ in 0..iterations {
            let _ = ash_verify_proof(&nonce, context_id, binding, &timestamp, &body_hash, &wrong_end);
        }
        let time_wrong_end = start.elapsed();

        // Should not have significant timing difference based on where mismatch is
        let max_time = time_wrong_start.max(time_wrong_middle).max(time_wrong_end);
        let min_time = time_wrong_start.min(time_wrong_middle).min(time_wrong_end);

        assert!(
            max_time.as_nanos() < min_time.as_nanos() * 3,
            "Verification timing varies based on mismatch position"
        );
    }
}

// =========================================================================
// ENCODING ATTACKS
// =========================================================================

mod encoding_attacks {
    use super::*;

    #[test]
    fn test_double_url_encoding_attack() {
        // %252F is double-encoded /
        let query1 = "path=%2F";      // Single encoded /
        let query2 = "path=%252F";    // Double encoded /

        let canon1 = ash_canonicalize_query(query1).unwrap();
        let canon2 = ash_canonicalize_query(query2).unwrap();

        // Should NOT be treated as the same
        assert_ne!(canon1, canon2, "Double encoding should be preserved, not decoded");
    }

    #[test]
    fn test_mixed_case_encoding_normalization() {
        let query1 = "key=%2f";  // lowercase
        let query2 = "key=%2F";  // uppercase

        let canon1 = ash_canonicalize_query(query1).unwrap();
        let canon2 = ash_canonicalize_query(query2).unwrap();

        assert_eq!(canon1, canon2, "Hex case should be normalized");
    }

    #[test]
    fn test_unicode_normalization_attack() {
        // Different Unicode representations of same character
        let json_nfc = r#"{"text":"cafÃ©"}"#;           // NFC: Ã© as single char
        let json_nfd = r#"{"text":"cafe\u0301"}"#;     // NFD: e + combining accent

        let canon_nfc = ash_canonicalize_json(json_nfc).unwrap();
        let canon_nfd = ash_canonicalize_json(json_nfd).unwrap();

        assert_eq!(canon_nfc, canon_nfd, "Unicode should be normalized to NFC");
    }

    #[test]
    fn test_unicode_homoglyph_distinction() {
        // Cyrillic 'Ð°' (U+0430) vs Latin 'a' (U+0061)
        let json1 = r#"{"key":"a"}"#;   // Latin a
        let json2 = "{\"key\":\"\u{0430}\"}";  // Cyrillic Ð°

        let canon1 = ash_canonicalize_json(json1).unwrap();
        let canon2 = ash_canonicalize_json(json2).unwrap();

        // These should be DIFFERENT - not confused as the same
        assert_ne!(canon1, canon2, "Homoglyphs should be distinguished");
    }

    #[test]
    fn test_bom_handling() {
        // UTF-8 BOM at start of JSON
        let json_with_bom = "\u{FEFF}{\"key\":\"value\"}";
        let json_without_bom = "{\"key\":\"value\"}";

        let result_with = ash_canonicalize_json(json_with_bom);
        let result_without = ash_canonicalize_json(json_without_bom);

        // Both should succeed and produce same output
        if let (Ok(c1), Ok(c2)) = (result_with, result_without) {
            assert_eq!(c1, c2, "BOM should be stripped");
        }
    }

    #[test]
    fn test_overlong_utf8_rejection() {
        // Overlong UTF-8 encoding of '/' is a security issue
        // In Rust, invalid UTF-8 is handled at the string level
        // This test verifies JSON with escape sequences works
        let json = r#"{"path":"\/api"}"#;
        let result = ash_canonicalize_json(json);
        assert!(result.is_ok());
    }

    #[test]
    fn test_surrogate_pair_handling() {
        // Emoji via surrogate pairs
        let json = r#"{"emoji":"\uD83D\uDE00"}"#;  // ðŸ˜€
        let result = ash_canonicalize_json(json);
        assert!(result.is_ok());
    }

    #[test]
    fn test_unmatched_surrogate_handling() {
        // Unmatched high surrogate
        let json = r#"{"bad":"\uD83D"}"#;
        let _result = ash_canonicalize_json(json);
        // Should either fail or handle gracefully
        // (behavior may vary)
    }
}

// =========================================================================
// RESOURCE EXHAUSTION
// =========================================================================

mod resource_exhaustion {
    use super::*;

    #[test]
    fn test_large_json_payload() {
        // 1MB payload - should be within limits
        let large_value = "x".repeat(1024 * 1024);
        let json = format!(r#"{{"data":"{}"}}"#, large_value);
        let result = ash_canonicalize_json(&json);
        assert!(result.is_ok(), "1MB payload should be accepted");
    }

    #[test]
    fn test_excessive_json_payload_rejected() {
        // 11MB payload - should be rejected
        let huge_value = "x".repeat(11 * 1024 * 1024);
        let json = format!(r#"{{"data":"{}"}}"#, huge_value);
        let result = ash_canonicalize_json(&json);
        assert!(result.is_err(), "11MB payload should be rejected");
    }

    #[test]
    fn test_deeply_nested_json_limit() {
        // Create deeply nested JSON (100 levels)
        let mut json = String::from("1");
        for _ in 0..100 {
            json = format!(r#"{{"a":{}}}"#, json);
        }
        let result = ash_canonicalize_json(&json);
        assert!(result.is_err(), "100 levels of nesting should be rejected");
    }

    #[test]
    fn test_acceptable_nesting_depth() {
        // 30 levels should be OK
        let mut json = String::from("1");
        for _ in 0..30 {
            json = format!(r#"{{"a":{}}}"#, json);
        }
        let result = ash_canonicalize_json(&json);
        assert!(result.is_ok(), "30 levels of nesting should be accepted");
    }

    #[test]
    fn test_many_object_keys() {
        // 1000 keys in one object
        let mut json = String::from("{");
        for i in 0..1000 {
            if i > 0 { json.push(','); }
            json.push_str(&format!(r#""key{}":{}"#, i, i));
        }
        json.push('}');

        let result = ash_canonicalize_json(&json);
        assert!(result.is_ok(), "1000 keys should be handled");
    }

    #[test]
    fn test_long_query_string() {
        // 1000 parameters
        let mut query = String::new();
        for i in 0..1000 {
            if i > 0 { query.push('&'); }
            query.push_str(&format!("key{}=value{}", i, i));
        }

        let result = ash_canonicalize_query(&query);
        assert!(result.is_ok(), "1000 query parameters should be handled");
    }

    #[test]
    fn test_many_scope_fields() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let binding = "POST|/api|";
        let timestamp = chrono::Utc::now().timestamp().to_string();

        let secret = ash_derive_client_secret(&nonce, context_id, binding).unwrap();

        // Create payload with 50 fields
        let mut payload_map = serde_json::Map::new();
        for i in 0..50 {
            payload_map.insert(format!("field{}", i), serde_json::json!(i));
        }
        let payload = serde_json::Value::Object(payload_map);
        let payload_str = serde_json::to_string(&payload).unwrap();

        // Scope with 50 fields should be OK
        let scope: Vec<String> = (0..50).map(|i| format!("field{}", i)).collect();
        let scope_refs: Vec<&str> = scope.iter().map(|s| s.as_str()).collect();

        let result = ash_build_proof_scoped(&secret, &timestamp, binding, &payload_str, &scope_refs);
        assert!(result.is_ok(), "50 scope fields should be accepted");
    }

    #[test]
    fn test_excessive_scope_fields_rejected() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let binding = "POST|/api|";
        let timestamp = chrono::Utc::now().timestamp().to_string();

        let secret = ash_derive_client_secret(&nonce, context_id, binding).unwrap();

        // Create payload with 150 fields
        let mut payload_map = serde_json::Map::new();
        for i in 0..150 {
            payload_map.insert(format!("field{}", i), serde_json::json!(i));
        }
        let payload = serde_json::Value::Object(payload_map);
        let payload_str = serde_json::to_string(&payload).unwrap();

        // Scope with 150 fields should be rejected
        let scope: Vec<String> = (0..150).map(|i| format!("field{}", i)).collect();
        let scope_refs: Vec<&str> = scope.iter().map(|s| s.as_str()).collect();

        let result = ash_build_proof_scoped(&secret, &timestamp, binding, &payload_str, &scope_refs);
        assert!(result.is_err(), "150 scope fields should be rejected");
    }
}

// =========================================================================
// SCOPED PROOF ATTACKS
// =========================================================================

mod scoped_proof_attacks {
    use super::*;

    #[test]
    fn test_scope_field_injection() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let binding = "POST|/api|";
        let timestamp = chrono::Utc::now().timestamp().to_string();

        let secret = ash_derive_client_secret(&nonce, context_id, binding).unwrap();

        let payload = r#"{"amount":100,"memo":"test"}"#;
        let scope = vec!["amount"];

        let (proof, scope_hash) = ash_build_proof_scoped(&secret, &timestamp, binding, payload, &scope).unwrap();

        // Try to add a field that looks like it's in scope
        let tampered = r#"{"amount":100,"memo":"test","amount.injected":9999}"#;
        let result = ash_verify_proof_scoped(&nonce, context_id, binding, &timestamp, tampered, &scope, &scope_hash, &proof).unwrap();

        // Should still verify since "amount" is unchanged
        assert!(result, "Added unscoped field should not affect verification");
    }

    #[test]
    fn test_scope_hash_tampering() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let binding = "POST|/api|";
        let timestamp = chrono::Utc::now().timestamp().to_string();

        let secret = ash_derive_client_secret(&nonce, context_id, binding).unwrap();

        let payload = r#"{"amount":100}"#;
        let scope = vec!["amount"];

        let (proof, _scope_hash) = ash_build_proof_scoped(&secret, &timestamp, binding, payload, &scope).unwrap();

        // Try with wrong scope hash
        let wrong_scope_hash = "0".repeat(64);
        let result = ash_verify_proof_scoped(&nonce, context_id, binding, &timestamp, payload, &scope, &wrong_scope_hash, &proof).unwrap();
        assert!(!result, "Wrong scope hash should fail verification");
    }

    #[test]
    fn test_scope_field_removal() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let binding = "POST|/api|";
        let timestamp = chrono::Utc::now().timestamp().to_string();

        let secret = ash_derive_client_secret(&nonce, context_id, binding).unwrap();

        let payload = r#"{"amount":100,"currency":"USD"}"#;
        let scope = vec!["amount", "currency"];

        let (proof, scope_hash) = ash_build_proof_scoped(&secret, &timestamp, binding, payload, &scope).unwrap();

        // Try to verify without currency field
        let tampered = r#"{"amount":100}"#;
        let result = ash_verify_proof_scoped(&nonce, context_id, binding, &timestamp, tampered, &scope, &scope_hash, &proof).unwrap();
        assert!(!result, "Removing scoped field should fail verification");
    }
}

// =========================================================================
// CHAINED PROOF ATTACKS
// =========================================================================

mod chained_proof_attacks {
    use super::*;

    #[test]
    fn test_chain_reordering_attack() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let timestamp = chrono::Utc::now().timestamp().to_string();

        // Step 1
        let binding1 = "POST|/api/step1|";
        let secret1 = ash_derive_client_secret(&nonce, context_id, binding1).unwrap();
        let result1 = ash_build_proof_unified(&secret1, &timestamp, binding1, "{}", &[], None).unwrap();

        // Step 2
        let binding2 = "POST|/api/step2|";
        let secret2 = ash_derive_client_secret(&nonce, context_id, binding2).unwrap();
        let result2 = ash_build_proof_unified(&secret2, &timestamp, binding2, "{}", &[], Some(&result1.proof)).unwrap();

        // Step 3
        let binding3 = "POST|/api/step3|";
        let secret3 = ash_derive_client_secret(&nonce, context_id, binding3).unwrap();
        let result3 = ash_build_proof_unified(&secret3, &timestamp, binding3, "{}", &[], Some(&result2.proof)).unwrap();

        // Try to verify step 3 with step 1 as previous (skipping step 2)
        let scope: &[&str] = &[];
        let valid = ash_verify_proof_unified(
            &nonce, context_id, binding3, &timestamp, "{}",
            &result3.proof, scope, &result3.scope_hash,
            Some(&result1.proof), &result3.chain_hash  // Wrong previous!
        ).unwrap();
        assert!(!valid, "Chain reordering should fail");
    }

    #[test]
    fn test_chain_injection_attack() {
        let nonce = "a".repeat(64);
        let context_id = "ctx_test";
        let timestamp = chrono::Utc::now().timestamp().to_string();

        // Legitimate step 1
        let binding1 = "POST|/api/step1|";
        let secret1 = ash_derive_client_secret(&nonce, context_id, binding1).unwrap();
        let result1 = ash_build_proof_unified(&secret1, &timestamp, binding1, "{}", &[], None).unwrap();

        // Attacker tries to inject their own step 2
        let fake_proof = "f".repeat(64);

        // Legitimate step 2 built on legitimate step 1
        let binding2 = "POST|/api/step2|";
        let secret2 = ash_derive_client_secret(&nonce, context_id, binding2).unwrap();
        let result2 = ash_build_proof_unified(&secret2, &timestamp, binding2, "{}", &[], Some(&result1.proof)).unwrap();

        // Verify with fake previous proof
        let scope: &[&str] = &[];
        let valid = ash_verify_proof_unified(
            &nonce, context_id, binding2, &timestamp, "{}",
            &result2.proof, scope, &result2.scope_hash,
            Some(&fake_proof), &result2.chain_hash
        ).unwrap();
        assert!(!valid, "Chain injection should fail");
    }
}
